[gd_scene load_steps=4 format=2]

[ext_resource path="res://cga.gd" type="Script" id=1]

[sub_resource type="Shader" id=1]
code = "// CGA raster shader
// svofski 2023
// input: CGA memory area from B800:0000, palette
// output: display texture
shader_type canvas_item;

uniform sampler2D b800; // hint_fuck
uniform vec2 mem_sz;    // input texture pixel size (80, 200)
uniform vec2 gobshite;  // output texture pixel size (320, 200)


vec4 cgacolor(vec2 uv)
{
	vec3 cga_palette[4] = {vec3(0.0,0.0,0.0), vec3(0.0,10.0/16.0,0.0), vec3(10.0/16.0, 0.0, 0.0), vec3(10.0/16.0, 5.0/16.0, 0.0)};
	
	ivec2 screen_xy = ivec2(floor(uv * gobshite)); // 0,0+320x200

	//int texel_y = int(screen_xy.y / 2) * 80 + 80*100*(screen_xy.y & 1);
	int texel_y = screen_xy.y / 2 + 100 * (screen_xy.y & 1);
	int texel_x = int(screen_xy.x / 4);
	
    int byte = ivec4(floor(255.0 * texelFetch(b800, ivec2(texel_x, texel_y), 0))).r;
	
	int pixel = screen_xy.x % 4;
	int shitf = 6 - (pixel << 1);
	
	//return vec4(vec3(float(screen_xy.y)/200.0, float(screen_xy.x)/320.0, float(shitf)/6.0), 1.0);
	//return vec4(vec3(float(screen_xy.y)/200.0, float(screen_xy.x)/320.0, float(byte)/255.0), 1.0);
	return vec4(cga_palette[(byte >> shitf) & 3], 1.0);	
	//return vec4(cga_palette[screen_xy.y % 4], 1.0);
}

void fragment() {
    vec4 c = cgacolor(UV);
    COLOR.rgba = c;
}
"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/mem_sz = Vector2( 80, 200 )
shader_param/gobshite = Vector2( 320, 200 )

[node name="cga" type="Panel"]
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 0
grow_vertical = 0
size_flags_horizontal = 2
size_flags_vertical = 2
script = ExtResource( 1 )

[node name="CgaTextureRect" type="TextureRect" parent="."]
material = SubResource( 2 )
anchor_right = 1.0
anchor_bottom = 1.0
expand = true
stretch_mode = 5
